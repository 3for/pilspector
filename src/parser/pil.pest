//root = { soi ~ (object | block) ~ eoi  }

polynomial = { "pol" ~ identifier ~ "=" ~ expression ~ ";" }

expression = { product ~ ( ( op_add | op_sub ) ~ product)* }
product = { unaried_term ~ (op_mul ~ unaried_term)* }
unaried_term = { op_unary? ~ powered_term }
powered_term = { postfixed_term ~ (op_pow ~ exponent_expression)? }
postfixed_term = { term ~ array_access? }
term = { ("(" ~ expression ~ ")")  | primary_expression }

array_access = { "[" ~ decimal_number ~ "]" }

primary_expression = { identifier | literal }

exponent_expression = { "(" ~ expression ~ ")" | primary_expression }

// End Expressions


identifier = @{ ((!keyword ~ ASCII_ALPHA) | (keyword ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }

// Literals for all types

literal = { decimal_literal }

decimal_literal = ${ decimal_number }
decimal_number = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }

// Operators

op_equal = @{"="}
op_add = {"+"}
op_sub = {"-"}
op_mul = {"*"}
op_pow = @{"**"}
op_neg = {"-"}

// `op_pow` is *not* in `op_binary` because its precedence is handled in this parser rather than down the line in precedence climbing
op_binary = _ { op_equal | op_add | op_sub | op_mul }
op_unary = { op_neg }

WHITESPACE = _{ " " | "\t" | "\\" | COMMENT | NEWLINE }
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)*) }

// the ordering of reserved keywords matters: if "as" is before "assert", then "assert" gets parsed as (as)(sert) and incorrectly
// accepted
keyword = @{
	"pol"|"commit"|"constant"
}
